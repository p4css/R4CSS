---
editor_options: 
  markdown: 
    wrap: 80
---

# Processing Timeline {#timeline}

現今網路上有許多開放資料可以供使用者下載或查詢，其中很多資料都包含了時間相關的訊息，例如訂單成立時間、氣象觀測時間、股價報價時間等等。這些時間資訊通常會以字串的方式儲存，但若要在程式中進行時間相關的運算，例如計算時間差、建立時間序列等，就必須先將其轉換為時間物件。在
R 裡面，常用的時間物件有 **`POSIXct`** 與 **`POSIXlt`** 兩種，我們可以使用
**`as.POSIXct()`** 或 **`as.POSIXlt()`**
函數將字串轉換為對應的時間物件。轉換完成後，我們就可以方便地進行時間相關的運算，例如計算兩個時間點之間的時間差、將時間轉換為不同的時區、擷取時間序列中的某個時間區間等等。這些時間相關的運算在很多領域都很常見，例如金融、氣象、交通等，因此學習如何使用時間物件進行運算是非常重要的一環。

**`POSIXct`** 以自從 1970 年 1 月 1 日 00:00:00 UTC
開始經過的秒數來表示一個時間點，而 **`POSIXlt`**
則是以結構化的列表方式來表示，其中包含了年、月、日、時、分、秒等元素。兩者最大的不同在於
**`POSIXct`** 更適合用於一些計算，而 **`POSIXlt`**
則更容易人類閱讀。我們可以使用 **`as.POSIXct()`** 或 **`as.POSIXlt()`**
函數來將一個字串轉換為對應的時間物件，也可以使用 **`Sys.time()`**
函數來取得當前的時間點。使用這些時間物件，我們可以方便地進行日期與時間的計算，例如算出兩個時間點之間的時間差，或是在時間序列上進行操作等。

```{r include=FALSE}
knitr::opts_chunk$set(echo=T, cache = T, warning = F, message = FALSE, class.output = "output")
library(knitr)
library(tidyverse)
options(scipen = 999)
```

## char-to-timestamp

在 R 裡面，我們可以使用 **`strptime()`** 函數將字串轉換為時間物件，其中
**`%Y`**、**`%m`**、**`%d`**、**`%H`**、**`%M`**、**`%S`**
等是用來表示時間的格式碼。在這段程式碼中，我們使用 **`strptime()`** 函數將
**`ptime`** 這個字串轉換為一個時間物件，其中 **`%Y-%m-%dT%H:%M:%SZ`**
是該字串的時間格式，也就是說這個字串是以 ISO 8601 的格式表示的時間，例如
**`2022-03-31T14:30:00Z`**。**`tz = "ASIA/Taipeiw"`**
則是指定時間所在的時區，這裡指定的是台灣時間。轉換完成後，我們使用
**`as.POSIXct()`** 函數將 **`strptime()`** 轉換出來的時間物件再轉換為 POSIXct
時間物件，並將其存入 **`ptime`** 這個欄位中。這段程式碼的作用是將一個 ISO 8601
格式的字串轉換為 POSIXct
時間物件，並指定時區為台灣，方便之後進行時間相關的運算。

在 **`strptime()`**
函數中，可以使用不同的格式碼來指定時間的格式。以下是常用的幾種格式碼及其意義：

-   **`%Y`**：四位數的年份，例如 2022。

-   **`%m`**：兩位數的月份，範圍是 01 到 12。

-   **`%d`**：兩位數的日期，範圍是 01 到 31。

-   **`%H`**：兩位數的小時，範圍是 00 到 23。

-   **`%M`**：兩位數的分鐘，範圍是 00 到 59。

-   **`%S`**：兩位數的秒數，範圍是 00 到 59。

-   **`%b`**：縮寫形式的月份名稱，例如 Jan。

-   **`%B`**：完整形式的月份名稱，例如 January。

-   **`%a`**：縮寫形式的星期幾名稱，例如 Mon。

-   **`%A`**：完整形式的星期幾名稱，例如 Monday。

-   **`%p`**：AM 或 PM，例如 AM。

在 **`strptime()`**
函數中，你可以使用這些格式碼來指定一個字串的時間格式，以便將其轉換為時間物件。例如，如果一個字串的格式是
**`2022-03-31 14:30:00`**，那麼可以使用 **`%Y-%m-%d %H:%M:%S`**
這個時間格式來將其轉換為一個時間物件。

```{r}

# Reading from url
# ptturl <- "https://github.com/P4CSS/R4CSSData/raw/main/ptt_hang_posts.csv"
# raw <- read.csv(url(ptturl))


# read.csv() won't convert timestamp to POSIXct automatically
# raw <- read.csv("data/ptt_hang_posts.csv")
# clean <- raw %>%
#         mutate(ptime = as.POSIXct(strptime(ptime, "%Y-%m-%dT%H:%M:%SZ")))


# read_csv() will convert timestamp to POSIXct automatically
clean <- read_csv("data/ptt_hang_posts.csv")
```

### Practice. Converting character to DateTime object

```{r}
t <- "2019-04-12T00:48:19Z"
class(t)
?strptime
t1 <- strptime(t, "%Y-%m-%dT%H:%M:%SZ")

t <- "Mon Mar 25 08:23:37 2024"
# Your Code Should be here
    
```

## Density plot along time

在資料分析的過程中，我們經常需要對資料進行分布分析，以了解資料的特性。**`ggplot2`**
套件提供了 **`geom_density()`** 函數，可以用來繪製密度圖（density
plot）。密度圖顯示了一個連續變量的概率密度函數的近似值，可以用來了解該變量的分佈情況。密度圖與直方圖類似，但它是基於核密度估計方法繪製的，所以在某些情況下可以提供更好的分佈近似。它將一個連續變量區間劃分為若干個小區間，然後對每個小區間的密度進行估計，再將這些小區間的密度估計值連接起來，形成一條平滑曲線，用以描述變量的分佈情況。

在 **`ggplot2`** 中，使用 **`geom_density()`**
函數可以很方便地繪製密度圖。我們只需要指定變量名稱，即可繪製出該變量的密度圖。此外，我們也可以使用
**`stat_density()`**
函數來繪製密度圖，這個函數允許我們對密度圖進行更多的自定義設置，例如指定核函數、調整帶寬等。繪製密度圖可以讓我們更直觀地了解變量的分佈情況，進而對資料進行更深入的分析和探索。

```{r}
clean %>%
    ggplot() + aes(ptime) + 
    geom_density()
    
```

## Freq by month

如果想要詳細觀察逐年逐月的變化，使用密度圖可能不夠直觀，此時可以考慮使用直方圖來呈現資料。直方圖可以將資料劃分為若干個等寬的區間，並計算每個區間內資料的頻率，然後將這些頻率顯示為長方形柱，以反映資料的分佈情況。對於時間序列資料，我們可以將其劃分為月、週等時間單位，然後計算每個時間單位內資料的出現次數，再使用
**`ggplot2`** 中的 **`geom_col()`** 函數繪製直方圖。

以上程式碼中，我們使用 **`mutate()`** 函數將 **`ptime`** 欄位轉換為月份
**`m`**，然後使用 **`count()`** 函數計算每個月份出現的次數。接著使用
**`ggplot()`** 函數初始化一個 **`ggplot`** 對象，指定 **`aes()`** 函數的 **`x`**
軸為月份 **`m`**，**`y`** 軸為出現次數 **`n`**，然後使用 **`geom_col()`**
函數繪製直方圖。這樣可以很直觀地看到每個月份資料的出現次數，進而觀察到逐年逐月的變化趨勢。如果需要更詳細的觀察，可以將資料劃分為更小的時間單位，例如週，然後使用類似的方法繪製直方圖。

```{r}
?lubridate
clean %>%
    mutate(m = month(ptime)) %>% 
    count(m) %>%
    ggplot() + aes(x=m, n) + 
    geom_col() + 
    scale_x_continuous(breaks = 1:12)
    
```

## Freq-by-date (good)

在處理時間序列資料時，我們常常需要將資料劃分為不同的時間單位，例如月、週、日等，以便進行更精細的分析和視覺化。然而，如果只是單純地提取出時間序列資料中的某一個時間單位，例如月份，就會失去時間軸在年的特性，因此需要採取一些方法來保留日期（如年）的特性。

以上程式碼中，我們使用 **`filter()`** 函數選取了時間範圍為 2019 年 3 月 18 日到
4 月 1 日的資料，然後使用 **`floor_date()`**
函數將每個時間點取整為當天的起始時間，以保留日期（如年）的特性。這樣可以確保同一天的資料都被歸到同一個時間單位中，進而保留時間軸在年的特性。接著使用
**`count()`** 函數計算每個時間單位內資料的出現次數，再使用 **`ggplot()`** 函數和
**`geom_col()`** 函數繪製直方圖，可以看到在時間軸上的年份特性被保留了下來。

總之，當我們需要從時間序列資料中提取某一個時間單位時，應該採用能夠保留日期（如年）特性的方法，例如使用
**`floor_date()`** 函數，以便進行更加精細的分析和視覺化。

```{r}
clean %>%
    filter(ptime >= as_date("2019-03-18") & ptime < as_date("2019-04-01")) %>%
    mutate(m = floor_date(ptime, unit = "day")) %>% 
    count(m) %>%
    ggplot() + aes(m, n) + 
    geom_col()
```

## Freq-by-hour

透過觀察資料在週末和週間的變化，可以幫助我們了解不同時間段的資料分佈情況。以下是一個範例程式碼，可以根據每天的時間點和文章數來觀察資料在週末和週間的變化。相較於將資料分為週間和週末，這個範例程式碼使用
X 軸作為 24 小時的時間點，而 Y
軸為不同日期的文章量，使用分組的方式，針對不同日期繪製折線圖，最後使用
**`facet_wrap()`** 函數將資料分成週末和週間兩個子圖來進行比較。

首先，我們使用 **`filter()`** 函數選取時間範圍為 2019 年 3 月 25 日到 4 月 1
日的資料。接著，使用 **`floor_date()`**
函數將每個時間點取整為當天的起始時間，以便進行統計。然後，使用 **`hour()`**
函數取出每個時間點的小時數，以及使用 **`count()`**
函數計算每個時間點和日期的文章數。接著，使用 **`wday()`**
函數取出每個日期的星期幾，並使用 **`ifelse()`**
函數將週末和週間的日期標記為不同的類別。最後，使用 **`ggplot()`** 函數初始化一個
**`ggplot`** 對象，指定 **`aes()`** 函數的 **`x`** 軸為小時數 **`h`**，**`y`**
軸為文章數 **`n`**，以及日期 **`d`** 的類別 **`color`**。然後，使用
**`geom_line()`** 函數繪製折線圖，並使用 **`facet_wrap()`**
函數將資料分為週末和週間兩個子圖。

透過這樣的方式，我們可以很清楚地看到週末和週間的文章量變化趨勢，從而對資料進行更深入的分析和探索。

```{r}
clean %>%
    filter(ptime >= as_datetime("2019-03-25") & ptime < as_datetime("2019-04-01")) %>%
    mutate(d = floor_date(ptime, unit = "day")) %>%
    mutate(h = hour(ptime)) %>%
    count(d, h) %>%
    mutate(wd = wday(d, label = F, locale = Sys.getlocale("LC_TIME"))) %>%
    mutate(isweekend = ifelse(wd >= 6, "weekend", "weekday")) %>%
    ggplot() + aes(h, n, color = as.character(d)) + 
    geom_line() + 
    facet_wrap(~isweekend)

?ifelse
```
